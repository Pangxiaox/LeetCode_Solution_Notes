# LeetCodeäºŒå‰æ ‘ç±»å‹é¢˜è§£

æ ‘çš„å­˜å‚¨ç»“æ„å®šä¹‰

```java
/* Definition for a binary tree node. */
public class TreeNode {
  int val;
  TreeNode left;
  TreeNode right;

  TreeNode(int x) {
    val = x;
  }
}
```



### å‰åºéå†

**è¿­ä»£**

```java
class Solution {
  public List<Integer> preorderTraversal(TreeNode root) {
    LinkedList<TreeNode> stack = new LinkedList<>();
    LinkedList<Integer> output = new LinkedList<>();
    if (root == null) {
      return output;
    }

    stack.add(root);
    while (!stack.isEmpty()) {
      TreeNode node = stack.pollLast(); //å¼¹å‡ºå¹¶è¿”å›é“¾è¡¨å°¾éƒ¨å…ƒç´ 
      output.add(node.val);
      if (node.right != null) {
        stack.add(node.right);
      }
      if (node.left != null) {
        stack.add(node.left);
      }
    }
    return output;
  }
}
```

é€šè¿‡è¿­ä»£ï¼Œå¼¹å‡ºå½“å‰æ ˆé¡¶å…ƒç´ ï¼Œå¹¶å°†å…¶å­©å­èŠ‚ç‚¹å‹å…¥æ ˆä¸­ï¼Œå…ˆå‹å³å­©å­å†å‹å·¦å­©å­ã€‚ï¼ˆ**æ³¨æ„æ­¤å¤„æ˜¯ä»¥é“¾è¡¨æ–¹å¼å®ç°**ï¼‰

**é€’å½’**

```java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
       List<Integer> list = new ArrayList<>();
        helper(root,list);
        return list;

    }

    public void helper(TreeNode root, List<Integer>res)
    {
        if(root==null)
            return;
        res.add(root.val);
        helper(root.left,res);
        helper(root.right,res);
    }
}
```



### ä¸­åºéå†

ğŸ‘**åŸºäºæ ˆçš„éå†**

```java
public class Solution {
    public List < Integer > inorderTraversal(TreeNode root) {
        List < Integer > res = new ArrayList < > ();
        Stack < TreeNode > stack = new Stack < > ();
        TreeNode curr = root;
        while (curr != null || !stack.isEmpty()) {
            while (curr != null) {
                stack.push(curr);
                curr = curr.left;
            }
            curr = stack.pop();
            res.add(curr.val);
            curr = curr.right;
        }
        return res;
    }
}
```

**é€’å½’**

```java
class Solution {
    public List < Integer > inorderTraversal(TreeNode root) {
        List < Integer > res = new ArrayList < > ();
        helper(root, res);
        return res;
    }

    public void helper(TreeNode root, List < Integer > res) {
        if (root != null) {
            if (root.left != null) {
                helper(root.left, res);
            }
            res.add(root.val);
            if (root.right != null) {
                helper(root.right, res);
            }
        }
    }
}
```



### ååºéå†

```java
class Solution {
  public List<Integer> postorderTraversal(TreeNode root) {
    LinkedList<TreeNode> stack = new LinkedList<>();
    LinkedList<Integer> output = new LinkedList<>();
    if (root == null) {
      return output;
    }

    stack.add(root);
    while (!stack.isEmpty()) {
      TreeNode node = stack.pollLast();
      output.addFirst(node.val);
      if (node.left != null) {
        stack.add(node.left);
      }
      if (node.right != null) {
        stack.add(node.right);
      }
    }
    return output;
  }
}
```

ä¸å‰åºéå†ç›¸ä¼¼ï¼Œè¿ç”¨è¿­ä»£æ€æƒ³



### å±‚æ¬¡éå†

```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> list = new ArrayList<>();
        if(root==null)
            return list;
        
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        while(!queue.isEmpty())
        {
            int cnt = queue.size();
            List<Integer> res = new ArrayList<>();
            while(cnt>0)
            {        
                TreeNode node = queue.poll();
                res.add(node.val);
                if(node.left!=null)
                {
                    queue.add(node.left);
                }
                if(node.right!=null)
                {
                    queue.add(node.right);
                }
                cnt--;
            }
            list.add(res);
        }
        return list;
    }
}
```

è¿­ä»£æ€æƒ³ï¼Œç”¨é˜Ÿåˆ—å®ç°



### æ±‚è§£äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦

**é€’å½’**

```java
class Solution {
  public int maxDepth(TreeNode root) {
    if (root == null) {
      return 0;
    } else {
      int left_height = maxDepth(root.left);
      int right_height = maxDepth(root.right);
      return java.lang.Math.max(left_height, right_height) + 1;
    }
  }
}
```



### å¯¹ç§°äºŒå‰æ ‘(ä¸€æ£µæ ‘è‡ªèº«å·¦å³å­æ ‘é•œåƒå¯¹ç§°)

**é€’å½’**

æ„é€ ä¸€æ£µä¸€æ¨¡ä¸€æ ·çš„æ–°æ ‘ï¼Œåˆ¤æ–­ä¸¤æ£µæ ‘æ˜¯å¦æ˜¯é•œåƒå¯¹ç§°ï¼Œè¿›è€Œåˆ¤å®šåŸæ ‘æ˜¯å¦æ˜¯å¯¹ç§°

```java
public boolean isSymmetric(TreeNode root) {
    return isMirror(root, root);
}

public boolean isMirror(TreeNode t1, TreeNode t2) {
    if (t1 == null && t2 == null) return true;
    if (t1 == null || t2 == null) return false;
    return (t1.val == t2.val)
        && isMirror(t1.right, t2.left)
        && isMirror(t1.left, t2.right);
}
```



### ç›¸åŒçš„æ ‘ï¼ˆä¸¤æ£µæ ‘å®Œå…¨ä¸€æ ·ï¼‰

**é€’å½’**

```java
class Solution {
  public boolean isSameTree(TreeNode p, TreeNode q) {
    // p and q are both null
    if (p == null && q == null) return true;
    // one of p and q is null
    if (q == null || p == null) return false;
    if (p.val != q.val) return false;
    return isSameTree(p.right, q.right) &&
            isSameTree(p.left, q.left);
  }
}
```



### äºŒå‰æ ‘çš„æœ€å°æ·±åº¦

æœ€å°æ·±åº¦æ˜¯ä»æ ¹èŠ‚ç‚¹åˆ°æœ€è¿‘å¶å­èŠ‚ç‚¹çš„æœ€çŸ­è·¯å¾„ä¸Šçš„èŠ‚ç‚¹æ•°é‡

**é€’å½’**

```java
class Solution {
    public int minDepth(TreeNode root) {
        if(root == null) return 0;
        int m1 = minDepth(root.left);
        int m2 = minDepth(root.right);
        //1.å¦‚æœå·¦å­©å­å’Œå³å­©å­æœ‰ä¸ºç©ºçš„æƒ…å†µï¼Œç›´æ¥è¿”å›m1+m2+1
        //2.å¦‚æœéƒ½ä¸ä¸ºç©ºï¼Œè¿”å›è¾ƒå°æ·±åº¦+1
        return root.left == null || root.right == null ? m1 + m2 + 1 : Math.min(m1,m2) + 1;
    }
}
```



### å¹³è¡¡äºŒå‰æ ‘

å¹³è¡¡äºŒå‰æ ‘ï¼šä¸€ä¸ªäºŒå‰æ ‘æ¯ä¸ªèŠ‚ç‚¹çš„å·¦å³ä¸¤ä¸ªå­æ ‘çš„é«˜åº¦å·®ç»å¯¹å€¼ä¸è¶…è¿‡1

```java
class Solution {
    public boolean isBalanced(TreeNode root) {
        return depth(root) != -1;
    }

    private int depth(TreeNode root) {
        if (root == null) return 0;
        int left = depth(root.left);
        if(left == -1) return -1;
        int right = depth(root.right);
        if(right == -1) return -1;
        return Math.abs(left - right) < 2 ? Math.max(left, right) + 1 : -1;
    }
}
```

å¦‚æœæ˜¯å¹³è¡¡çš„ï¼Œé‚£ä¹ˆå°±è¿”å›æ ‘çš„å±‚æ•°ï¼›å¦‚æœä¸æ˜¯å¹³è¡¡çš„ï¼Œå°±è¿”å›-1.

**æå‰é˜»æ–­**ï¼šå½“å‘ç°å·¦å³å­æ ‘é«˜åº¦å·®å¤§äº1ï¼Œå°±ç›´æ¥è¿”å›-1ã€‚



### ç¿»è½¬äºŒå‰æ ‘

æŒ‰å±‚åºéå†ç¼–å·ï¼šè¾“å…¥äºŒå‰æ ‘ï¼š4ã€2ã€7ã€1ã€3ã€6ã€9ï¼Œè¾“å‡ºäºŒå‰æ ‘4ã€7ã€2ã€9ã€6ã€3ã€1

**é€’å½’**

```java
public TreeNode invertTree(TreeNode root) {
    if (root == null) {
        return null;
    }
    TreeNode right = invertTree(root.right);
    TreeNode left = invertTree(root.left);
    root.left = right;
    root.right = left;
    return root;
}
```



### äºŒå‰æœç´¢æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ

å…¬å…±ç¥–å…ˆèŠ‚ç‚¹å¯ä»¥ä¸ºèŠ‚ç‚¹æœ¬èº«

**é€’å½’**

æ ¹æ®BSTçš„æ€§è´¨ï¼š

å¦‚æœpå’Œqéƒ½åœ¨å³å­æ ‘ä¸Šï¼Œé‚£ä¹ˆä»¥å³å­©å­ä¸ºæ ¹èŠ‚ç‚¹ç»§ç»­éå†

å¦‚æœpå’Œqéƒ½åœ¨å·¦å­æ ‘ä¸Šï¼Œé‚£ä¹ˆä»¥å·¦å­©å­ä¸ºæ ¹èŠ‚ç‚¹ç»§ç»­éå†

å¦‚æœä¸Šè¿°ä¸¤ä¸ªéƒ½ä¸æˆç«‹åˆ™ä»£è¡¨å·²ç»æ‰¾åˆ°LCAèŠ‚ç‚¹

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        int parentVal = root.val;
        int pVal = p.val;
        int qVal = q.val;

        if (pVal > parentVal && qVal > parentVal) {
            return lowestCommonAncestor(root.right, p, q);
        } else if (pVal < parentVal && qVal < parentVal) {
            return lowestCommonAncestor(root.left, p, q);
        } else {
            return root;
        }
    }
}
```



### äºŒå‰æœç´¢æ ‘ä¸­ç¬¬kå°çš„å…ƒç´ 

è¾“å…¥ï¼šroot = [3,1,4,null,2]ï¼Œk=1ï¼ˆrootæŒ‰å±‚æ¬¡éå†æ’åˆ—ï¼‰

è¾“å‡ºï¼š1

**æ„é€ BSTä¸­åºéå†åºåˆ—ï¼Œç¬¬k-1ä¸ªå…ƒç´ ï¼ˆä¸‹æ ‡ï¼‰å°±æ˜¯ç¬¬kå°çš„å…ƒç´ **

```java
class Solution {
  public ArrayList<Integer> inorder(TreeNode root, ArrayList<Integer> arr) {
    if (root == null) return arr;
    inorder(root.left, arr);
    arr.add(root.val);
    inorder(root.right, arr);
    return arr;
  }

  public int kthSmallest(TreeNode root, int k) {
    ArrayList<Integer> nums = inorder(root, new ArrayList<Integer>());
    return nums.get(k - 1);
  }
}
```



### äºŒå‰æ ‘å±•å¼€æˆé“¾è¡¨

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼ŒåŸåœ°å°†å®ƒå±•å¼€ä¸ºé“¾è¡¨  

![Image text](https://github.com/Pangxiaox/LeetCode_Solution_Notes/blob/master/LeetCode-pic/Leetcode1.PNG)  

**å±•å¼€é¡ºåºå°±æ˜¯äºŒå‰æ ‘çš„å‰åºéå†**

**1.å°†å·¦å­æ ‘æ’å…¥åˆ°å³å­æ ‘çš„åœ°æ–¹  2. å°†åŸæ¥çš„å³å­æ ‘æ¥åˆ°å·¦å­æ ‘çš„æœ€å³è¾¹èŠ‚ç‚¹  3.è€ƒè™‘æ–°çš„å³å­æ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œä¸€ç›´é‡å¤ä¸Šè¿°è¿‡ç¨‹ï¼Œç›´åˆ°æ–°çš„å³å­æ ‘ä¸ºnull**

```java
public void flatten(TreeNode root) {
    while (root != null) { 
        //å·¦å­æ ‘ä¸º nullï¼Œç›´æ¥è€ƒè™‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
        if (root.left == null) {
            root = root.right;
        } else {
            // æ‰¾å·¦å­æ ‘æœ€å³è¾¹çš„èŠ‚ç‚¹
            TreeNode pre = root.left;
            while (pre.right != null) {
                pre = pre.right;
            } 
            //å°†åŸæ¥çš„å³å­æ ‘æ¥åˆ°å·¦å­æ ‘çš„æœ€å³è¾¹èŠ‚ç‚¹
            pre.right = root.right;
            // å°†å·¦å­æ ‘æ’å…¥åˆ°å³å­æ ‘çš„åœ°æ–¹
            root.right = root.left;
            root.left = null;
            // è€ƒè™‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
            root = root.right;
        }
    }
}
```



### éªŒè¯äºŒå‰æœç´¢æ ‘

**ä¸­åºéå†ï¼ŒéªŒè¯å…ƒç´ å¤§å°æ˜¯å¦ä¸æ–­å¢å¤§**

```java
class Solution {
  public boolean isValidBST(TreeNode root) {
    Stack<TreeNode> stack = new Stack();
    double inorder = - Double.MAX_VALUE;

    while (!stack.isEmpty() || root != null) {
      while (root != null) {
        stack.push(root);
        root = root.left;
      }
      root = stack.pop();
      // If next element in inorder traversal
      // is smaller than the previous one
      // that's not BST.
      if (root.val <= inorder) return false;
      inorder = root.val;
      root = root.right;
    }
    return true;
  }
}
```



### åˆå¹¶äºŒå‰æ ‘  

![Image text](https://github.com/Pangxiaox/LeetCode_Solution_Notes/blob/master/LeetCode-pic/LeetCode2.PNG)  

**é€’å½’**

```java
public class Solution {
    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {
        if (t1 == null)
            return t2;
        if (t2 == null)
            return t1;
        t1.val += t2.val;
        t1.left = mergeTrees(t1.left, t2.left);
        t1.right = mergeTrees(t1.right, t2.right);
        return t1;
    }
}
```



### äºŒå‰æ ‘çš„å³è§†å›¾  

![Image text](https://github.com/Pangxiaox/LeetCode_Solution_Notes/blob/master/LeetCode-pic/LeetCode3.PNG)  

**å±‚åºéå†ï¼Œæ¯æ¬¡å‘ç»“æœä¸­æ·»åŠ æ¯å±‚æœ€å³è¾¹å…ƒç´ **

```java
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if(root == null) return res;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        while(!queue.isEmpty()){
            int count = queue.size();
            while(count > 0){
                count--;
                TreeNode cur = queue.poll();
                if(count == 0){
                    res.add(cur.val);
                }
                if(cur.left != null){
                    queue.add(cur.left);
                }
                if(cur.right != null){
                    queue.add(cur.right);
                }
            }
        }
        return res;
    }
```



### å°†æœ‰åºæ•°ç»„è½¬æ¢ä¸ºäºŒå‰æœç´¢æ ‘

å°†ä¸€ä¸ªå‡åºæ’åˆ—æ•°ç»„è½¬æ¢ä¸ºä¸€æ£µé«˜åº¦å¹³è¡¡çš„äºŒå‰æœç´¢æ ‘

é«˜åº¦å¹³è¡¡äºŒå‰æ ‘æ˜¯æŒ‡ä¸€ä¸ªäºŒå‰æ ‘æ¯ä¸ªèŠ‚ç‚¹çš„å·¦å³ä¸¤ä¸ªå­æ ‘é«˜åº¦å·®ç»å¯¹å€¼ä¸è¶…è¿‡1

**å‡åºæ•°ç»„å°±æ˜¯ä¸­åºéå†çš„ç»“æœã€‚æ ¹èŠ‚ç‚¹è®¾ç½®ä¸ºæ•°ç»„ä¸­ç‚¹ï¼Œæä¾›äº†æ ¹èŠ‚ç‚¹ï¼Œç„¶åé€’å½’ç”Ÿæˆå·¦å³å­æ ‘**

```java
public TreeNode sortedArrayToBST(int[] nums) {
    return sortedArrayToBST(nums, 0, nums.length);
}

private TreeNode sortedArrayToBST(int[] nums, int start, int end) {
    if (start == end) {
        return null;
    }
    int mid = (start + end) >>> 1;
    TreeNode root = new TreeNode(nums[mid]);
    root.left = sortedArrayToBST(nums, start, mid);
    root.right = sortedArrayToBST(nums, mid + 1, end);

    return root;
}
```



### äºŒå‰æ ‘çš„é”¯é½¿å½¢å±‚æ¬¡éå†  

![Image text](https://github.com/Pangxiaox/LeetCode_Solution_Notes/blob/master/LeetCode-pic/LeetCode4.PNG)  

**éå†ç¬¬äºŒå±‚èŠ‚ç‚¹é¡ºåºå·¦åˆ°å³ï¼Œè¾“å‡ºç¬¬äºŒå±‚èŠ‚ç‚¹é¡ºåºå³åˆ°å·¦ï¼›éå†ç¬¬ä¸‰å±‚èŠ‚ç‚¹é¡ºåºå³åˆ°å·¦ï¼Œè¾“å‡ºç¬¬ä¸‰å±‚èŠ‚ç‚¹é¡ºåºå·¦åˆ°å³ã€‚äº¤æ›¿ä½¿ç”¨ä¸¤ä¸ªæ ˆéå†æ‰€æœ‰å±‚**

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
    	List<List<Integer>> list = new ArrayList<>();
        if (root == null) {
        	return list;
        }
        //æ ˆ1æ¥å­˜å‚¨å³èŠ‚ç‚¹åˆ°å·¦èŠ‚ç‚¹çš„é¡ºåº
        Stack<TreeNode> stack1 = new Stack<>(); 
        //æ ˆ2æ¥å­˜å‚¨å·¦èŠ‚ç‚¹åˆ°å³èŠ‚ç‚¹çš„é¡ºåº
        Stack<TreeNode> stack2 = new Stack<>();
        
        //æ ¹èŠ‚ç‚¹å…¥æ ˆ
    	stack1.push(root);
    	
    	//æ¯æ¬¡å¾ªç¯ä¸­ï¼Œéƒ½æ˜¯ä¸€ä¸ªæ ˆä¸ºç©ºï¼Œä¸€ä¸ªæ ˆä¸ä¸ºç©ºï¼Œç»“æŸçš„æ¡ä»¶ä¸¤ä¸ªéƒ½ä¸ºç©º
        while (!stack1.isEmpty() || !stack2.isEmpty()) {
        	List<Integer> subList = new ArrayList<>(); // å­˜å‚¨è¿™ä¸€ä¸ªå±‚çš„æ•°æ®
        	TreeNode cur = null;
        	
        	if (!stack1.isEmpty()) { //æ ˆ1ä¸ä¸ºç©ºï¼Œåˆ™æ ˆ2æ­¤æ—¶ä¸ºç©ºï¼Œéœ€è¦ç”¨æ ˆ2æ¥å­˜å‚¨ä»ä¸‹ä¸€å±‚ä»å·¦åˆ°å³çš„é¡ºåº
        		while (!stack1.isEmpty()) {	//éå†æ ˆ1ä¸­æ‰€æœ‰å…ƒç´ ï¼Œå³å½“å‰å±‚çš„æ‰€æœ‰å…ƒç´ 
        			cur = stack1.pop();
        			subList.add(cur.val);	//å­˜å‚¨å½“å‰å±‚æ‰€æœ‰å…ƒç´ 
        			
        			if (cur.left != null) {	//å·¦èŠ‚ç‚¹ä¸ä¸ºç©ºåŠ å…¥ä¸‹ä¸€å±‚
        				stack2.push(cur.left);
        			}
        			if (cur.right != null) {	//å³èŠ‚ç‚¹ä¸ä¸ºç©ºåŠ å…¥ä¸‹ä¸€å±‚
        				stack2.push(cur.right);
        			}
        		}
        		list.add(subList);
        	}else {//æ ˆ2ä¸ä¸ºç©ºï¼Œåˆ™æ ˆ1æ­¤æ—¶ä¸ºç©ºï¼Œéœ€è¦ç”¨æ ˆ1æ¥å­˜å‚¨ä»ä¸‹ä¸€å±‚ä»å³åˆ°å·¦çš„é¡ºåº
        		while (!stack2.isEmpty()) {
        			cur = stack2.pop();
        			subList.add(cur.val);
        			
        			if (cur.right != null) {//å³èŠ‚ç‚¹ä¸ä¸ºç©ºåŠ å…¥ä¸‹ä¸€å±‚
        				stack1.push(cur.right);
        			}
        			if (cur.left != null) { //å·¦èŠ‚ç‚¹ä¸ä¸ºç©ºåŠ å…¥ä¸‹ä¸€å±‚
        				stack1.push(cur.left);
        			}
        		}
        		list.add(subList);
        	}
        }
        return list;
    }
}
```



### ä»å‰åºä¸ä¸­åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘

**é€’å½’**

**ä½¿ç”¨HashMapæŠŠä¸­åºéå†æ•°ç»„æ¯ä¸ªå…ƒç´ å€¼å’Œä¸‹æ ‡å­˜èµ·æ¥ï¼Œç›´æ¥å¾—åˆ°æ ¹èŠ‚ç‚¹ä½ç½®**

```java
public TreeNode buildTree(int[] preorder, int[] inorder) {
    return buildTreeHelper(preorder, 0, preorder.length, inorder, 0, inorder.length);
}

private TreeNode buildTreeHelper(int[] preorder, int p_start, int p_end, int[] inorder, int i_start, int i_end) {
    // preorder ä¸ºç©ºï¼Œç›´æ¥è¿”å› null
    if (p_start == p_end) {
        return null;
    }
    int root_val = preorder[p_start];
    TreeNode root = new TreeNode(root_val);
    //åœ¨ä¸­åºéå†ä¸­æ‰¾åˆ°æ ¹èŠ‚ç‚¹çš„ä½ç½®
    int i_root_index = 0;
    for (int i = i_start; i < i_end; i++) {
        if (root_val == inorder[i]) {
            i_root_index = i;
            break;
        }
    }
    int leftNum = i_root_index - i_start;
    //é€’å½’çš„æ„é€ å·¦å­æ ‘
    root.left = buildTreeHelper(preorder, p_start + 1, p_start + leftNum + 1, inorder, i_start, i_root_index);
    //é€’å½’çš„æ„é€ å³å­æ ‘
    root.right = buildTreeHelper(preorder, p_start + leftNum + 1, p_end, inorder, i_root_index + 1, i_end);
    return root;
}
```



### ä»ä¸­åºä¸ååºéå†åºåˆ—æ„é€ äºŒå‰æ ‘

**é€’å½’**

**å…ˆåœ¨ååºéå†åºåˆ—ä¸­æ‰¾åˆ°æ ¹èŠ‚ç‚¹ï¼ˆæœ€åä¸€ä¸ªå…ƒç´ ï¼‰ï¼Œç„¶åæ ¹æ®æ ¹èŠ‚ç‚¹åœ¨ä¸­åºéå†åºåˆ—ä¸­æ‰¾åˆ°æ ¹èŠ‚ç‚¹ä½ç½®ï¼Œå†æ ¹æ®æ ¹èŠ‚ç‚¹ä½ç½®ç¡®å®šå·¦å­æ ‘å’Œå³å­æ ‘åœ¨ä¸­åºæ•°ç»„å’Œååºæ•°ç»„ä¸­ä½ç½®ï¼Œé€’å½’æ„é€ å·¦å­æ ‘å’Œå³å­æ ‘**

```java
class Solution {

    HashMap<Integer,Integer> memo = new HashMap<>();
    int[] post;

    public TreeNode buildTree(int[] inorder, int[] postorder) {
        for(int i = 0;i < inorder.length; i++) memo.put(inorder[i], i);
        post = postorder;
        TreeNode root = buildTree(0, inorder.length - 1, 0, post.length - 1);
        return root;
    }

    public TreeNode buildTree(int is, int ie, int ps, int pe) {
        if(ie < is || pe < ps) return null;

        int root = post[pe];
        int ri = memo.get(root);

        TreeNode node = new TreeNode(root);
        node.left = buildTree(is, ri - 1, ps, ps + ri - is - 1);
        node.right = buildTree(ri + 1, ie, ps + ri - is, pe - 1);
        return node;
    }
}
```



### äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ

å¯¹äºæœ‰æ ¹æ ‘Tçš„ä¸¤ä¸ªèŠ‚ç‚¹pã€qï¼Œæœ€è¿‘å…¬å…±ç¥–å…ˆè¡¨ç¤ºä¸ºä¸€ä¸ªèŠ‚ç‚¹xï¼Œæ»¡è¶³xæ˜¯pã€qçš„ç¥–å…ˆä¸”xçš„æ·±åº¦å°½å¯èƒ½å¤§ï¼ˆä¸€ä¸ªèŠ‚ç‚¹ä¹Ÿå¯ä»¥æ˜¯å®ƒè‡ªå·±çš„ç¥–å…ˆï¼‰

**ä½¿ç”¨çˆ¶æŒ‡é’ˆçš„è¿­ä»£**

**ä»æ ¹èŠ‚ç‚¹å¼€å§‹éå†ï¼Œåœ¨æ‰¾åˆ°på’Œqä¹‹å‰å°†çˆ¶æŒ‡é’ˆå­˜å‚¨åœ¨å­—å…¸ä¸­ã€‚ä¸€æ—¦æ‰¾åˆ°på’Œqï¼Œè·å–pçš„æ‰€æœ‰ç¥–å…ˆï¼ŒåŠ åˆ°ä¸€ä¸ªæ–°çš„é›†åˆä¸­ï¼ŒåŒæ ·å»éå†qçš„ç¥–å…ˆï¼Œå¦‚æœè¿™ä¸ªç¥–å…ˆå­˜åœ¨äºé›†åˆä¸­ï¼Œé‚£ä¹ˆè¿™ä¸ªå°±æ˜¯æœ€è¿‘å…¬å…±ç¥–å…ˆ**

```java
class Solution {

    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {

        // Stack for tree traversal
        Deque<TreeNode> stack = new ArrayDeque<>();

        // HashMap for parent pointers
        Map<TreeNode, TreeNode> parent = new HashMap<>();

        parent.put(root, null);
        stack.push(root);

        // Iterate until we find both the nodes p and q
        while (!parent.containsKey(p) || !parent.containsKey(q)) {

            TreeNode node = stack.pop();

            // While traversing the tree, keep saving the parent pointers.
            if (node.left != null) {
                parent.put(node.left, node);
                stack.push(node.left);
            }
            if (node.right != null) {
                parent.put(node.right, node);
                stack.push(node.right);
            }
        }

        // Ancestors set() for node p.
        Set<TreeNode> ancestors = new HashSet<>();

        // Process all ancestors for node p using parent pointers.
        while (p != null) {
            ancestors.add(p);
            p = parent.get(p);
        }

        // The first ancestor of q which appears in
        // p's ancestor set() is their lowest common ancestor.
        while (!ancestors.contains(q))
            q = parent.get(q);
        return q;
    }
}
```



### äºŒå‰æ ‘çš„ç›´å¾„

ä»»æ„ä¸¤ä¸ªèŠ‚ç‚¹è·¯å¾„é•¿åº¦ä¸­çš„æœ€å¤§å€¼ï¼Œå¯èƒ½ç©¿è¿‡æ ¹èŠ‚ç‚¹

```java
class Solution {
    int ans;
    public int diameterOfBinaryTree(TreeNode root) {
        ans=1;
        depth(root);
        return ans-1;
    }

    public int depth(TreeNode node){
        if(node==null) return 0;
        int L = depth(node.left);
        int R = depth(node.right);
        ans = Math.max(ans, L+R+1);
        return Math.max(L,R)+1;
    }
}
```



